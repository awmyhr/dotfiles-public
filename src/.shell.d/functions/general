#!/bin/bash
#===============================================================================
#
#         FILE: .shell.d/functions/general
#
#        USAGE: (should be sourced by .shell.d/settings)
#
#  DESCRIPTION: Functoins for use across shells.
#
#      OPTIONS: ---
# REQUIREMENTS: Bourne-compatible shell
#    OPTIONALS: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: awmyhr, awmyhr@gmail.com
#      VERSION: 1.0.0
#      CREATED: ????-??-??
#     REVISION: 2016-09-30
#===============================================================================
#----------------------------------------------------------------------
#-- Notes/known bugs/other issues
#----------------------------------------------------------------------

###############################################################################
### Functions for general use

function timestamp() {
    date "${DEFAULT_TIMESTAMP}"
}

# Originally found here: http://www.etalabs.net/sh_tricks.html
stringmatch() {
    case "${2}" in 
        *${1}*) 
            return 0 
            ;; 
        *) 
            return 1 
            ;; 
    esac ;
    return 20
}

# This was originally taken from /etc/profile on Fedora 24
pathmunge() {
    case ":${PATH}:" in
        *:"${1}":*)
            ;;
        *)
            if [ "${2}" = "after" ] ; then
                PATH="${PATH}:${1}"
            else
                PATH="${1}:${PATH}"
            fi
    esac
}
# Until I figure out how to use a variable to assing a value to another variable
manpathmunge() {
    case ":${MANPATH}:" in
        *:"${1}":*)
            ;;
        *)
            if [ "${2}" = "after" ] ; then
                MANPATH="${MANPATH}:${1}"
            else
                MANPATH="${1}:${MANPATH}"
            fi
    esac
}

# This is originally from: http://blog.isonoe.net/post/2010/10/01/Split-a-string-by-character(s)-in-POSIX-shell
split() {
    local string IFS
 
    string="${1}"
    IFS="${2}"
    shift 2
    read -r -- "$@" <<EOF
$string
EOF
}

###############################################################################
### Functions for prompts

# need a solid, quick way to detect svn/fossil/darcs repos (copied and modified from some zsh thing)
function _vcs_prompt_char() {
    git branch >/dev/null 2>/dev/null && echo $VCS_GIT && return
    hg  root   >/dev/null 2>/dev/null && echo $VCS_HG  && return
    #svn status >/dev/null 2>/dev/null && echo $VCS_SVN && return
    #fossile status  >/dev/null 2>/dev/null && echo $VCS_FOSSIL && return
    #darcs status  >/dev/null 2>/dev/null && echo $VCS_DARCS && return
    echo $VCS_NONE
}

# Get the status of the working tree (copied and modified from git.zsh)
function _git_prompt_status() {
    ## NOTE: this may not work in git versions older than 1.7.2
    local GITSTAT=''
    local STATUS=''
    ## NOTE: This method of building FLAGS isn't compatible w/bash
    ##       I've tried many different things, can't quite get it...
    local FLAGS=('--porcelain')
    FLAGS+=' -b'
    #local FLAGS=('--porcelain -b')
    [[ "$VCS_IGNORE_SUBMODULES" == "true" ]]      && FLAGS+='--ignore-submodules'
    [[ "$VCS_IGNORE_UNTRACKED_FILES" == "true" ]] && FLAGS+='--untracked-files=no'
    GITSTAT=$(eval command git status ${FLAGS} 2> /dev/null)
   #GITSTAT=$(eval command git status ${FLAGS})

    # Ahead/behind/diverged
    if $(echo "$GITSTAT" | grep '^## [^ ]\+ .*ahead' &> /dev/null); then
        STATUS="${c_pDEBUG}${VCS_AHEAD}$STATUS "
    elif $(echo "$GITSTAT" | grep '^## [^ ]\+ .*behind' &> /dev/null); then
        STATUS="${c_pCRIT}${VCS_BEHIND}$STATUS "
    elif $(echo "$GITSTAT" | grep '^## [^ ]\+ .*diverged' &> /dev/null); then
        STATUS="${c_pEMERG}${VCS_DIVERGED}$STATUS "
    fi
    GITSTAT=`echo $GITSTAT | sed 1d`

    if [[ -n $GITSTAT ]]; then
        STATUS="${c_pCRIT}${VCS_DIRTY}$STATUS"
        # Non-staged
        if $(echo "$GITSTAT" | grep '^?? ' &> /dev/null); then
            STATUS="${STATUS}${c_pNOTICE}${VCS_UNTRACKED}"
        fi
        if $(echo "$GITSTAT" | grep '^UU ' &> /dev/null); then
            STATUS="${STATUS}${c_pCRIT}${VCS_UNMERGED}"
        fi
        if $(echo "$GITSTAT" | grep '^ D ' &> /dev/null); then
            STATUS="${STATUS}${c_pCRIT}${VCS_DELETED}"
        fi

        if $(echo "$GITSTAT" | grep '^.M ' &> /dev/null); then
            STATUS="${STATUS}${c_pWARNING}${VCS_MODIFIED}"
        elif $(echo "$GITSTAT" | grep '^AM ' &> /dev/null); then
            STATUS="${STATUS}${c_pWARNING}${VCS_MODIFIED}"
        elif $(echo "$GITSTAT" | grep '^ T ' &> /dev/null); then
            STATUS="${STATUS}${c_pWARNING}${VCS_MODIFIED}"
        fi

        # Staged
        if $(echo "$GITSTAT" | grep '^D  ' &> /dev/null); then
            STATUS="${STATUS}${c_pINFO}${VCS_DELETED}"
        fi
        if $(echo "$GITSTAT" | grep '^R' &> /dev/null); then
            STATUS="${STATUS}${c_pINFO}${VCS_RENAMED}"
        fi
        if $(echo "$GITSTAT" | grep '^M' &> /dev/null); then
            STATUS="${STATUS}${c_pINFO}${VCS_MODIFIED}"
        fi
        if $(echo "$GITSTAT" | grep '^A' &> /dev/null); then
            STATUS="${STATUS}${c_pINFO}${VCS_ADDED}"
        fi
        if $(echo "$GITSTAT" | grep '^C' &> /dev/null); then
            STATUS="${STATUS}${c_pINFO}${VCS_COPIED}"
        fi
    else
        STATUS="${c_pINFO}${VCS_CLEAN}$STATUS"
    fi

    # Put a space at the beginning
    if $(echo -n "$STATUS" | grep '.*' &> /dev/null); then
        STATUS=" $STATUS"
    fi

    echo $STATUS
}

# Checks if working tree is dirty (copied and modified from git.zsh)
function _parse_git_dirty() {
    ## NOTE: this may not work in git versions older than 1.7.2
    local GITSTAT=''
    local FLAGS=('--porcelain')
    [[ "$VCS_IGNORE_SUBMODULES" == "true" ]]      && FLAGS+='--ignore-submodules'
    [[ "$VCS_IGNORE_UNTRACKED_FILES" == "true" ]] && FLAGS+='--untracked-files=no'
    GITSTAT=$(eval command git status $FLAGS 2> /dev/null | tail -n1)

    if [[ -n $GITSTAT ]]; then
        echo " ${c_pCRIT}$VCS_DIRTY"
    else
        echo " ${c_pINFO}$VCS_CLEAN"
    fi
}

# get the name of the branch we are on (copied and modified from git.zsh)
function _git_prompt() {
    ref=$(git symbolic-ref HEAD 2> /dev/null) || return
    echo " ${c_pDEBUG}‹${ref#refs/heads/}$(_git_prompt_status)${c_pDEBUG}›"
}

function _return_code() { 
    exit_code=$?
    [[ $exit_code -ne 0 ]] && printf -- "$exit_code ↵"
}
###############################################################################
### Limited use functions
if [[ -x '/opt/pbis/bin/find-user-by-name' ]]; then
  function name() { /opt/pbis/bin/find-user-by-name "$@" | grep -i gecos | awk '{ print $2 " " $3; }'; }
else
  function name() { echo 'PBIS not found.'; }
fi
