#!/bin/sh
#===============================================================================
#
#         FILE: .shell.d/lib/functions
#
#        USAGE: (should be sourced by .shell.d/shellinit)
#
#  DESCRIPTION: General functions for use across shells.
#
#      OPTIONS: ---
# REQUIREMENTS: Bourne-compatible shell
#    OPTIONALS: (various vcs commands - git, hg)
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: awmyhr, awmyhr@gmail.com
#      VERSION: 1.0.0-alpha
#      CREATED: ????-??-??
#     REVISION: 2016-10-04
#===============================================================================
#----------------------------------------------------------------------
#-- Notes/known bugs/other issues
#----------------------------------------------------------------------

#=== FUNCTION ==================================================================
# NAME: timestamp
# DESCRIPTION: Return currant date/time in user-defined format for appending to 
#               a filename (or some other similar thing)
#    REQUIRED: Environment variable DEFAULT_TIMESTAMP containing format string
#               for date command.
#===============================================================================
timestamp() {
    date "${DEFAULT_TIMESTAMP}"
}

#=== FUNCTION ==================================================================
# NAME: stringmatch
# DESCRIPTION: return true if second string contains first string, false if not
#       USAGE: stringmatch needle heystack
#===============================================================================
# Originally found here: http://www.etalabs.net/sh_tricks.html
stringmatch() {
    case "${2}" in 
        *${1}*) 
            return 0 
            ;; 
        *) 
            return 1 
            ;; 
    esac ;
    return 1        # This should never execute
}

#=== FUNCTION ==================================================================
# NAME: pathmunge
# DESCRIPTION: Add a directory to PATH
#       USAGE: pathmunge /new/path [after]
#===============================================================================
# This was originally taken from /etc/profile on Fedora 24
pathmunge() {
    case ":${PATH}:" in
        *:"${1}":*)
            ;;
        *)
            if [ "${2}" = "after" ] ; then
                PATH="${PATH}:${1}"
            else
                PATH="${1}:${PATH}"
            fi
    esac
}

#=== FUNCTION ==================================================================
# NAME: manpathmunge
# DESCRIPTION: Add a directory to MANPATH
#       USAGE: manpathmunge /new/man/path [after]
#===============================================================================
# Until I figure out how to use a variable to assing a value to another variable
manpathmunge() {
    case ":${MANPATH}:" in
        *:"${1}":*)
            ;;
        *)
            if [ "${2}" = "after" ] ; then
                MANPATH="${MANPATH}:${1}"
            else
                MANPATH="${1}:${MANPATH}"
            fi
    esac
}

#=== FUNCTION ==================================================================
# NAME: splitvar
# DESCRIPTION: split a series of words into different varaibles
#       USAGE: splitvar "word list" ' ' VAR1 VAR2
#===============================================================================
# This is originally from: http://blog.isonoe.net/post/2010/10/01/Split-a-string-by-character(s)-in-POSIX-shell
splitvar() {
    local string IFS
 
    string="${1}"
    IFS="${2}"
    shift 2
    read -r -- "$@" <<EOF
$string
EOF
}

#=== FUNCTION ==================================================================
# NAME: _vcs_prompt_char
# DESCRIPTION: This will detect the presence of a vcs command, check if the
#               current directory is a repo for that command, and return
#               a symbol (defined in shell.d/lib/symbols)
#===============================================================================
# need a solid, quick way to detect svn/fossil/darcs repos (copied and modified from some zsh thing)
_vcs_prompt_char() {
    command -v git >/dev/null 2>&1 && {
        git branch >/dev/null 2>&1 && printf -- "${VCS_GIT}" && return
    }
    command -v hg  >/dev/null 2>&1 && {
        hg  root   >/dev/null 2>&1 && printf -- "${VCS_HG}"  && return
    }
    # command -v svn    >/dev/null 2>&1 && {
    #     svn    STATUS >/dev/null 2>&1 && printf -- "${VCS_SVN}"    && return
    # }
    # command -v fossil >/dev/null 2>&1 && {
    #     fossil STATUS >/dev/null 2>&1 && printf -- "${VCS_FOSSIL}" && return
    # }
    # command -v darcs  >/dev/null 2>&1 && {
    #     darcs  STATUS >/dev/null 2>&1 && printf -- "${VCS_DARCS}"  && return
    # }
    printf -- "${VCS_NONE}"
}

#=== FUNCTION ==================================================================
# NAME: _return_code
# DESCRIPTION: This will detect if the last command had a non-zero return code.
#               If so, it will return that code for prompt display
#===============================================================================
_return_code() { 
    exit_code="${?}"
    [ "${exit_code}" -ne 0 ] && printf -- "${exit_code} â†µ"
}

#===============================================================================
#----------------------------------------------------------------------
export ISSET_FUNCTIONS=1
#----------------------------------------------------------------------
#===============================================================================
